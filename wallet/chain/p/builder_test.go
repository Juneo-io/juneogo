// Copyright (C) 2019-2024, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

package p

import (
	"testing"
	"time"

	"github.com/stretchr/testify/require"

	"github.com/Juneo-io/juneogo/ids"
	"github.com/Juneo-io/juneogo/utils/constants"
	"github.com/Juneo-io/juneogo/utils/crypto/bls"
	"github.com/Juneo-io/juneogo/utils/crypto/secp256k1"
	"github.com/Juneo-io/juneogo/utils/set"
	"github.com/Juneo-io/juneogo/utils/units"
	"github.com/Juneo-io/juneogo/vms/components/avax"
	"github.com/Juneo-io/juneogo/vms/platformvm/reward"
	"github.com/Juneo-io/juneogo/vms/platformvm/signer"
	"github.com/Juneo-io/juneogo/vms/platformvm/stakeable"
	"github.com/Juneo-io/juneogo/vms/platformvm/txs"
	"github.com/Juneo-io/juneogo/vms/secp256k1fx"
	"github.com/Juneo-io/juneogo/wallet/chain/p/builder"
	"github.com/Juneo-io/juneogo/wallet/supernet/primary/common"
)

var (
	testKeys = secp256k1.TestKeys()

	// We hard-code [avaxAssetID] and [supernetAssetID] to make
	// ordering of UTXOs generated by [testUTXOsList] is reproducible
	avaxAssetID   = ids.Empty.Prefix(1789)
	supernetAssetID = ids.Empty.Prefix(2024)

	testContext = &builder.Context{
		NetworkID:                     constants.UnitTestID,
		AVAXAssetID:                   avaxAssetID,
		BaseTxFee:                     units.MicroAvax,
		CreateSupernetTxFee:             19 * units.MicroAvax,
		TransformSupernetTxFee:          789 * units.MicroAvax,
		CreateBlockchainTxFee:         1234 * units.MicroAvax,
		AddPrimaryNetworkValidatorFee: 19 * units.MilliAvax,
		AddPrimaryNetworkDelegatorFee: 765 * units.MilliAvax,
		AddSupernetValidatorFee:         1010 * units.MilliAvax,
		AddSupernetDelegatorFee:         9 * units.Avax,
	}
)

// These tests create a tx, then verify that utxos included in the tx are
// exactly necessary to pay fees for it.

func TestBaseTx(t *testing.T) {
	var (
		require = require.New(t)

		// backend
		utxosKey   = testKeys[1]
		utxos      = makeTestUTXOs(utxosKey)
		chainUTXOs = common.NewDeterministicChainUTXOs(require, map[ids.ID][]*avax.UTXO{
			constants.PlatformChainID: utxos,
		})
		backend = NewBackend(testContext, chainUTXOs, nil)

		// builder
		utxoAddr = utxosKey.Address()
		builder  = builder.New(set.Of(utxoAddr), testContext, backend)

		// data to build the transaction
		outputsToMove = []*avax.TransferableOutput{{
			Asset: avax.Asset{ID: avaxAssetID},
			Out: &secp256k1fx.TransferOutput{
				Amt: 7 * units.Avax,
				OutputOwners: secp256k1fx.OutputOwners{
					Threshold: 1,
					Addrs:     []ids.ShortID{utxoAddr},
				},
			},
		}}
	)

	utx, err := builder.NewBaseTx(outputsToMove)
	require.NoError(err)

	// check UTXOs selection and fee financing
	ins := utx.Ins
	outs := utx.Outs
	require.Len(ins, 2)
	require.Len(outs, 2)

	expectedConsumed := testContext.BaseTxFee + outputsToMove[0].Out.Amount()
	consumed := ins[0].In.Amount() + ins[1].In.Amount() - outs[0].Out.Amount()
	require.Equal(expectedConsumed, consumed)
	require.Equal(outputsToMove[0], outs[1])
}

func TestAddSupernetValidatorTx(t *testing.T) {
	var (
		require = require.New(t)

		// backend
		utxosKey   = testKeys[1]
		utxos      = makeTestUTXOs(utxosKey)
		chainUTXOs = common.NewDeterministicChainUTXOs(require, map[ids.ID][]*avax.UTXO{
			constants.PlatformChainID: utxos,
		})

		supernetID       = ids.GenerateTestID()
		supernetAuthKey  = testKeys[0]
		supernetAuthAddr = supernetAuthKey.Address()
		supernetOwner    = &secp256k1fx.OutputOwners{
			Threshold: 1,
			Addrs:     []ids.ShortID{supernetAuthAddr},
		}
		supernets = map[ids.ID]*txs.Tx{
			supernetID: {
				Unsigned: &txs.CreateSupernetTx{
					Owner: supernetOwner,
				},
			},
		}

		backend = NewBackend(testContext, chainUTXOs, supernets)

		// builder
		utxoAddr = utxosKey.Address()
		builder  = builder.New(set.Of(utxoAddr, supernetAuthAddr), testContext, backend)

		// data to build the transaction
		supernetValidator = &txs.SupernetValidator{
			Validator: txs.Validator{
				NodeID: ids.GenerateTestNodeID(),
				End:    uint64(time.Now().Add(time.Hour).Unix()),
			},
			Supernet: supernetID,
		}
	)

	// build the transaction
	utx, err := builder.NewAddSupernetValidatorTx(supernetValidator)
	require.NoError(err)

	// check UTXOs selection and fee financing
	ins := utx.Ins
	outs := utx.Outs
	require.Len(ins, 2)
	require.Len(outs, 1)

	expectedConsumed := testContext.AddSupernetValidatorFee
	consumed := ins[0].In.Amount() + ins[1].In.Amount() - outs[0].Out.Amount()
	require.Equal(expectedConsumed, consumed)
}

func TestRemoveSupernetValidatorTx(t *testing.T) {
	var (
		require = require.New(t)

		// backend
		utxosKey   = testKeys[1]
		utxos      = makeTestUTXOs(utxosKey)
		chainUTXOs = common.NewDeterministicChainUTXOs(require, map[ids.ID][]*avax.UTXO{
			constants.PlatformChainID: utxos,
		})

		supernetID       = ids.GenerateTestID()
		supernetAuthKey  = testKeys[0]
		supernetAuthAddr = supernetAuthKey.Address()
		supernetOwner    = &secp256k1fx.OutputOwners{
			Threshold: 1,
			Addrs:     []ids.ShortID{supernetAuthAddr},
		}
		supernets = map[ids.ID]*txs.Tx{
			supernetID: {
				Unsigned: &txs.CreateSupernetTx{
					Owner: supernetOwner,
				},
			},
		}

		backend = NewBackend(testContext, chainUTXOs, supernets)

		// builder
		utxoAddr = utxosKey.Address()
		builder  = builder.New(set.Of(utxoAddr, supernetAuthAddr), testContext, backend)
	)

	// build the transaction
	utx, err := builder.NewRemoveSupernetValidatorTx(
		ids.GenerateTestNodeID(),
		supernetID,
	)
	require.NoError(err)

	// check UTXOs selection and fee financing
	ins := utx.Ins
	outs := utx.Outs
	require.Len(ins, 1)
	require.Len(outs, 1)

	expectedConsumed := testContext.BaseTxFee
	consumed := ins[0].In.Amount() - outs[0].Out.Amount()
	require.Equal(expectedConsumed, consumed)
}

func TestCreateChainTx(t *testing.T) {
	var (
		require = require.New(t)

		// backend
		utxosKey   = testKeys[1]
		utxos      = makeTestUTXOs(utxosKey)
		chainUTXOs = common.NewDeterministicChainUTXOs(require, map[ids.ID][]*avax.UTXO{
			constants.PlatformChainID: utxos,
		})

		supernetID       = ids.GenerateTestID()
		supernetAuthKey  = testKeys[0]
		supernetAuthAddr = supernetAuthKey.Address()
		supernetOwner    = &secp256k1fx.OutputOwners{
			Threshold: 1,
			Addrs:     []ids.ShortID{supernetAuthAddr},
		}
		supernets = map[ids.ID]*txs.Tx{
			supernetID: {
				Unsigned: &txs.CreateSupernetTx{
					Owner: supernetOwner,
				},
			},
		}

		backend = NewBackend(testContext, chainUTXOs, supernets)

		utxoAddr = utxosKey.Address()
		builder  = builder.New(set.Of(utxoAddr, supernetAuthAddr), testContext, backend)

		// data to build the transaction
		genesisBytes = []byte{'a', 'b', 'c'}
		vmID         = ids.GenerateTestID()
		fxIDs        = []ids.ID{ids.GenerateTestID()}
		chainName    = "dummyChain"
		chainAssetID = ids.Empty
	)

	// build the transaction
	utx, err := builder.NewCreateChainTx(
		supernetID,
		genesisBytes,
		vmID,
		fxIDs,
		chainName,
		chainAssetID,
	)
	require.NoError(err)

	// check UTXOs selection and fee financing
	ins := utx.Ins
	outs := utx.Outs
	require.Len(ins, 1)
	require.Len(outs, 1)

	expectedConsumed := testContext.CreateBlockchainTxFee
	consumed := ins[0].In.Amount() - outs[0].Out.Amount()
	require.Equal(expectedConsumed, consumed)
}

func TestCreateSupernetTx(t *testing.T) {
	var (
		require = require.New(t)

		// backend
		utxosKey   = testKeys[1]
		utxos      = makeTestUTXOs(utxosKey)
		chainUTXOs = common.NewDeterministicChainUTXOs(require, map[ids.ID][]*avax.UTXO{
			constants.PlatformChainID: utxos,
		})

		supernetID       = ids.GenerateTestID()
		supernetAuthKey  = testKeys[0]
		supernetAuthAddr = supernetAuthKey.Address()
		supernetOwner    = &secp256k1fx.OutputOwners{
			Threshold: 1,
			Addrs:     []ids.ShortID{supernetAuthAddr},
		}
		supernets = map[ids.ID]*txs.Tx{
			supernetID: {
				Unsigned: &txs.CreateSupernetTx{
					Owner: supernetOwner,
				},
			},
		}

		backend = NewBackend(testContext, chainUTXOs, supernets)

		// builder
		utxoAddr = utxosKey.Address()
		builder  = builder.New(set.Of(utxoAddr, supernetAuthAddr), testContext, backend)
	)

	// build the transaction
	utx, err := builder.NewCreateSupernetTx(supernetOwner)
	require.NoError(err)

	// check UTXOs selection and fee financing
	ins := utx.Ins
	outs := utx.Outs
	require.Len(ins, 1)
	require.Len(outs, 1)

	expectedConsumed := testContext.CreateSupernetTxFee
	consumed := ins[0].In.Amount() - outs[0].Out.Amount()
	require.Equal(expectedConsumed, consumed)
}

func TestTransferSupernetOwnershipTx(t *testing.T) {
	var (
		require = require.New(t)

		// backend
		utxosKey   = testKeys[1]
		utxos      = makeTestUTXOs(utxosKey)
		chainUTXOs = common.NewDeterministicChainUTXOs(require, map[ids.ID][]*avax.UTXO{
			constants.PlatformChainID: utxos,
		})

		supernetID       = ids.GenerateTestID()
		supernetAuthKey  = testKeys[0]
		supernetAuthAddr = supernetAuthKey.Address()
		supernetOwner    = &secp256k1fx.OutputOwners{
			Threshold: 1,
			Addrs:     []ids.ShortID{supernetAuthAddr},
		}
		supernets = map[ids.ID]*txs.Tx{
			supernetID: {
				Unsigned: &txs.CreateSupernetTx{
					Owner: supernetOwner,
				},
			},
		}

		backend = NewBackend(testContext, chainUTXOs, supernets)

		// builder
		utxoAddr = utxosKey.Address()
		builder  = builder.New(set.Of(utxoAddr, supernetAuthAddr), testContext, backend)
	)

	// build the transaction
	utx, err := builder.NewTransferSupernetOwnershipTx(
		supernetID,
		supernetOwner,
	)
	require.NoError(err)

	// check UTXOs selection and fee financing
	ins := utx.Ins
	outs := utx.Outs
	require.Len(ins, 1)
	require.Len(outs, 1)

	expectedConsumed := testContext.BaseTxFee
	consumed := ins[0].In.Amount() - outs[0].Out.Amount()
	require.Equal(expectedConsumed, consumed)
}

func TestImportTx(t *testing.T) {
	var (
		require = require.New(t)

		// backend
		utxosKey      = testKeys[1]
		utxos         = makeTestUTXOs(utxosKey)
		sourceChainID = ids.GenerateTestID()
		importedUTXOs = utxos[:1]
		chainUTXOs    = common.NewDeterministicChainUTXOs(require, map[ids.ID][]*avax.UTXO{
			constants.PlatformChainID: utxos,
			sourceChainID:             importedUTXOs,
		})

		backend = NewBackend(testContext, chainUTXOs, nil)

		// builder
		utxoAddr = utxosKey.Address()
		builder  = builder.New(set.Of(utxoAddr), testContext, backend)

		// data to build the transaction
		importKey = testKeys[0]
		importTo  = &secp256k1fx.OutputOwners{
			Threshold: 1,
			Addrs: []ids.ShortID{
				importKey.Address(),
			},
		}
	)

	// build the transaction
	utx, err := builder.NewImportTx(
		sourceChainID,
		importTo,
	)
	require.NoError(err)

	// check UTXOs selection and fee financing
	ins := utx.Ins
	outs := utx.Outs
	importedIns := utx.ImportedInputs
	require.Empty(ins) // we spend the imported input (at least partially)
	require.Len(importedIns, 1)
	require.Len(outs, 1)

	expectedConsumed := testContext.BaseTxFee
	consumed := importedIns[0].In.Amount() - outs[0].Out.Amount()
	require.Equal(expectedConsumed, consumed)
}

func TestExportTx(t *testing.T) {
	var (
		require = require.New(t)

		// backend
		utxosKey   = testKeys[1]
		utxos      = makeTestUTXOs(utxosKey)
		chainUTXOs = common.NewDeterministicChainUTXOs(require, map[ids.ID][]*avax.UTXO{
			constants.PlatformChainID: utxos,
		})
		backend = NewBackend(testContext, chainUTXOs, nil)

		// builder
		utxoAddr = utxosKey.Address()
		builder  = builder.New(set.Of(utxoAddr), testContext, backend)

		// data to build the transaction
		supernetID        = ids.GenerateTestID()
		exportedOutputs = []*avax.TransferableOutput{{
			Asset: avax.Asset{ID: avaxAssetID},
			Out: &secp256k1fx.TransferOutput{
				Amt: 7 * units.Avax,
				OutputOwners: secp256k1fx.OutputOwners{
					Threshold: 1,
					Addrs:     []ids.ShortID{utxoAddr},
				},
			},
		}}
	)

	// build the transaction
	utx, err := builder.NewExportTx(
		supernetID,
		exportedOutputs,
	)
	require.NoError(err)

	// check UTXOs selection and fee financing
	ins := utx.Ins
	outs := utx.Outs
	require.Len(ins, 2)
	require.Len(outs, 1)

	expectedConsumed := testContext.BaseTxFee + exportedOutputs[0].Out.Amount()
	consumed := ins[0].In.Amount() + ins[1].In.Amount() - outs[0].Out.Amount()
	require.Equal(expectedConsumed, consumed)
	require.Equal(utx.ExportedOutputs, exportedOutputs)
}

func TestTransformSupernetTx(t *testing.T) {
	var (
		require = require.New(t)

		// backend
		utxosKey   = testKeys[1]
		utxos      = makeTestUTXOs(utxosKey)
		chainUTXOs = common.NewDeterministicChainUTXOs(require, map[ids.ID][]*avax.UTXO{
			constants.PlatformChainID: utxos,
		})

		supernetID       = ids.GenerateTestID()
		supernetAuthKey  = testKeys[0]
		supernetAuthAddr = supernetAuthKey.Address()
		supernetOwner    = &secp256k1fx.OutputOwners{
			Threshold: 1,
			Addrs:     []ids.ShortID{supernetAuthAddr},
		}
		supernets = map[ids.ID]*txs.Tx{
			supernetID: {
				Unsigned: &txs.CreateSupernetTx{
					Owner: supernetOwner,
				},
			},
		}

		backend = NewBackend(testContext, chainUTXOs, supernets)

		// builder
		utxoAddr = utxosKey.Address()
		builder  = builder.New(set.Of(utxoAddr, supernetAuthAddr), testContext, backend)

		// data to build the transaction
		initialRewardPoolSupply = 40 * units.MegaAvax
	)

	// build the transaction
	utx, err := builder.NewTransformSupernetTx(
		supernetID,
		supernetAssetID,
		initialRewardPoolSupply, // initial reward pool supply
		1_0000, // start reward share
		uint64(time.Date(2000, time.January, 1, 0, 0, 0, 0, time.UTC).Unix()), // start reward time
		8000, // diminishing reward share
		uint64(time.Date(2001, time.January, 1, 0, 0, 0, 0, time.UTC).Unix()), // diminishing reward time
		6000, // target reward share
		uint64(time.Date(2002, time.January, 1, 0, 0, 0, 0, time.UTC).Unix()), // target reward time
		1,                             // min validator stake
		100*units.MegaAvax,            // max validator stake
		time.Second,                   // min stake duration
		365*24*time.Hour,              // max stake duration
		2_0000,                        // stake period reward share
		0,                             // min delegation fee
		0,                             // max delegation fee
		1,                             // min delegator stake
		5,                             // max validator weight factor
		.80*reward.PercentDenominator, // uptime requirement
	)
	require.NoError(err)

	// check UTXOs selection and fee financing
	ins := utx.Ins
	outs := utx.Outs
	require.Len(ins, 2)
	require.Len(outs, 2)

	expectedConsumedSupernetAsset := initialRewardPoolSupply
	consumedSupernetAsset := ins[0].In.Amount() - outs[1].Out.Amount()
	require.Equal(expectedConsumedSupernetAsset, consumedSupernetAsset)
	expectedConsumed := testContext.TransformSupernetTxFee
	consumed := ins[1].In.Amount() - outs[0].Out.Amount()
	require.Equal(expectedConsumed, consumed)
}

func TestAddPermissionlessValidatorTx(t *testing.T) {
	var (
		require = require.New(t)

		// backend
		utxosKey   = testKeys[1]
		utxos      = makeTestUTXOs(utxosKey)
		chainUTXOs = common.NewDeterministicChainUTXOs(require, map[ids.ID][]*avax.UTXO{
			constants.PlatformChainID: utxos,
		})
		backend = NewBackend(testContext, chainUTXOs, nil)

		// builder
		utxoAddr   = utxosKey.Address()
		rewardKey  = testKeys[0]
		rewardAddr = rewardKey.Address()
		builder    = builder.New(set.Of(utxoAddr, rewardAddr), testContext, backend)

		// data to build the transaction
		validationRewardsOwner = &secp256k1fx.OutputOwners{
			Threshold: 1,
			Addrs: []ids.ShortID{
				rewardAddr,
			},
		}
		delegationRewardsOwner = &secp256k1fx.OutputOwners{
			Threshold: 1,
			Addrs: []ids.ShortID{
				rewardAddr,
			},
		}
	)

	sk, err := bls.NewSecretKey()
	require.NoError(err)

	// build the transaction
	utx, err := builder.NewAddPermissionlessValidatorTx(
		&txs.SupernetValidator{
			Validator: txs.Validator{
				NodeID: ids.GenerateTestNodeID(),
				End:    uint64(time.Now().Add(time.Hour).Unix()),
				Wght:   2 * units.Avax,
			},
			Supernet: constants.PrimaryNetworkID,
		},
		signer.NewProofOfPossession(sk),
		avaxAssetID,
		validationRewardsOwner,
		delegationRewardsOwner,
		reward.PercentDenominator,
	)
	require.NoError(err)

	// check UTXOs selection and fee financing
	ins := utx.Ins
	staked := utx.StakeOuts
	outs := utx.Outs
	require.Len(ins, 4)
	require.Len(staked, 2)
	require.Len(outs, 2)

	expectedConsumedSupernetAsset := utx.Validator.Weight()
	consumedSupernetAsset := staked[0].Out.Amount() + staked[1].Out.Amount()
	require.Equal(expectedConsumedSupernetAsset, consumedSupernetAsset)
	expectedConsumed := testContext.AddPrimaryNetworkValidatorFee
	consumed := ins[1].In.Amount() + ins[3].In.Amount() - outs[0].Out.Amount()
	require.Equal(expectedConsumed, consumed)
}

func TestAddPermissionlessDelegatorTx(t *testing.T) {
	var (
		require = require.New(t)

		// backend
		utxosKey   = testKeys[1]
		utxos      = makeTestUTXOs(utxosKey)
		chainUTXOs = common.NewDeterministicChainUTXOs(require, map[ids.ID][]*avax.UTXO{
			constants.PlatformChainID: utxos,
		})
		backend = NewBackend(testContext, chainUTXOs, nil)

		// builder
		utxoAddr   = utxosKey.Address()
		rewardKey  = testKeys[0]
		rewardAddr = rewardKey.Address()
		builder    = builder.New(set.Of(utxoAddr, rewardAddr), testContext, backend)

		// data to build the transaction
		rewardsOwner = &secp256k1fx.OutputOwners{
			Threshold: 1,
			Addrs: []ids.ShortID{
				rewardAddr,
			},
		}
	)

	// build the transaction
	utx, err := builder.NewAddPermissionlessDelegatorTx(
		&txs.SupernetValidator{
			Validator: txs.Validator{
				NodeID: ids.GenerateTestNodeID(),
				End:    uint64(time.Now().Add(time.Hour).Unix()),
				Wght:   2 * units.Avax,
			},
			Supernet: constants.PrimaryNetworkID,
		},
		avaxAssetID,
		rewardsOwner,
	)
	require.NoError(err)

	// check UTXOs selection and fee financing
	ins := utx.Ins
	staked := utx.StakeOuts
	outs := utx.Outs
	require.Len(ins, 4)
	require.Len(staked, 2)
	require.Len(outs, 2)

	expectedConsumedSupernetAsset := utx.Validator.Weight()
	consumedSupernetAsset := staked[0].Out.Amount() + staked[1].Out.Amount()
	require.Equal(expectedConsumedSupernetAsset, consumedSupernetAsset)
	expectedConsumed := testContext.AddPrimaryNetworkDelegatorFee
	consumed := ins[1].In.Amount() + ins[3].In.Amount() - outs[0].Out.Amount()
	require.Equal(expectedConsumed, consumed)
}

func makeTestUTXOs(utxosKey *secp256k1.PrivateKey) []*avax.UTXO {
	// Note: we avoid ids.GenerateTestNodeID here to make sure that UTXO IDs won't change
	// run by run. This simplifies checking what utxos are included in the built txs.
	const utxosOffset uint64 = 2024

	utxosAddr := utxosKey.Address()
	return []*avax.UTXO{
		{ // a small UTXO first, which should not be enough to pay fees
			UTXOID: avax.UTXOID{
				TxID:        ids.Empty.Prefix(utxosOffset),
				OutputIndex: uint32(utxosOffset),
			},
			Asset: avax.Asset{ID: avaxAssetID},
			Out: &secp256k1fx.TransferOutput{
				Amt: 2 * units.MilliAvax,
				OutputOwners: secp256k1fx.OutputOwners{
					Locktime:  0,
					Addrs:     []ids.ShortID{utxosAddr},
					Threshold: 1,
				},
			},
		},
		{ // a locked, small UTXO
			UTXOID: avax.UTXOID{
				TxID:        ids.Empty.Prefix(utxosOffset + 1),
				OutputIndex: uint32(utxosOffset + 1),
			},
			Asset: avax.Asset{ID: avaxAssetID},
			Out: &stakeable.LockOut{
				Locktime: uint64(time.Now().Add(time.Hour).Unix()),
				TransferableOut: &secp256k1fx.TransferOutput{
					Amt: 3 * units.MilliAvax,
					OutputOwners: secp256k1fx.OutputOwners{
						Threshold: 1,
						Addrs:     []ids.ShortID{utxosAddr},
					},
				},
			},
		},
		{ // a supernetAssetID denominated UTXO
			UTXOID: avax.UTXOID{
				TxID:        ids.Empty.Prefix(utxosOffset + 2),
				OutputIndex: uint32(utxosOffset + 2),
			},
			Asset: avax.Asset{ID: supernetAssetID},
			Out: &secp256k1fx.TransferOutput{
				Amt: 99 * units.MegaAvax,
				OutputOwners: secp256k1fx.OutputOwners{
					Locktime:  0,
					Addrs:     []ids.ShortID{utxosAddr},
					Threshold: 1,
				},
			},
		},
		{ // a locked, large UTXO
			UTXOID: avax.UTXOID{
				TxID:        ids.Empty.Prefix(utxosOffset + 3),
				OutputIndex: uint32(utxosOffset + 3),
			},
			Asset: avax.Asset{ID: avaxAssetID},
			Out: &stakeable.LockOut{
				Locktime: uint64(time.Now().Add(time.Hour).Unix()),
				TransferableOut: &secp256k1fx.TransferOutput{
					Amt: 88 * units.Avax,
					OutputOwners: secp256k1fx.OutputOwners{
						Threshold: 1,
						Addrs:     []ids.ShortID{utxosAddr},
					},
				},
			},
		},
		{ // a large UTXO last, which should be enough to pay any fee by itself
			UTXOID: avax.UTXOID{
				TxID:        ids.Empty.Prefix(utxosOffset + 4),
				OutputIndex: uint32(utxosOffset + 4),
			},
			Asset: avax.Asset{ID: avaxAssetID},
			Out: &secp256k1fx.TransferOutput{
				Amt: 9 * units.Avax,
				OutputOwners: secp256k1fx.OutputOwners{
					Locktime:  0,
					Addrs:     []ids.ShortID{utxosAddr},
					Threshold: 1,
				},
			},
		},
	}
}
